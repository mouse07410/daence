\documentclass{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[T1]{fontenc}
\usepackage[final=true,backref=page,colorlinks=true]{hyperref}[2016/05/21]
\usepackage[final]{listings}
\usepackage[numbers]{natbib}

\title{\DAENCE/:
  \Salsa20/ and \ChaCha/ in Deterministic Authenticated Encryption \\
  with no noNCEnse}
\author{Taylor `Riastradh' Campbell}

\bibliographystyle{plainnat}
\renewcommand*{\backrefalt}[4]{%
  \ifcase#1% no citations
  \or% one citation
    Cited on p.~#2.%
  \else% multiple citations
    Cited on pp.~#2.%
  \fi%
}
\DeclareUrlCommand\doi{%
  \def\UrlLeft##1\UrlRight{DOI~\href{https://doi.org/##1}{##1}}%
  \urlstyle{rm}}
\DeclareUrlCommand\url{%
  \def\UrlLeft##1\UrlRight{\href{##1}{##1}}%
  \urlstyle{tt}}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newcommand{\term}[1]{\textbf{#1}}

\newcommand{\margintodo}[1]{%
  \leavevmode\marginpar{\leavevmode%
    \parskip=4pt plus 2pt minus 1pt\relax%
    \color{red}%
    TODO: #1%
  }%
}

\def\operatorsc#1{{%
  \ifmmode\let\next=\operatorname\else\let\next=\relax\fi\next{\textsc{#1}}}}
\def\Salsa#1/{\operatorsc{Salsa#1}}
\def\ChaCha#1/{\operatorsc{ChaCha#1}}
\def\HChaCha#1/{\operatorsc{HChaCha#1}}
\def\HSalsa#1/{\operatorsc{HSalsa#1}}
\def\XChaCha#1/{\operatorsc{XChaCha#1}}
\def\HXChaCha#1/{\operatorsc{HXChaCha#1}}
\def\XSalsa#1/{\operatorsc{XSalsa#1}}
\def\HXSalsa#1/{\operatorsc{HXSalsa#1}}
\def\Poly#1/{\operatorsc{Poly#1}}
\def\Auth#1/{\operatorsc{Auth#1}}
\def\DAENCE/{\operatorsc{Daence}}
\def\DUNCE/{\operatorsc{Dunce}}
\def\DEUCE/{\operatorsc{Deuce}}
\def\DICE/{\operatorsc{Dice}}

\def\CAESAR/{\textsc{Caesar}}
\def\OCB/{OCB}
\def\NaCl/{NaCl}
\def\IETF/{IETF}
\def\TLS/{TLS}
\def\IV/{\textsc{iv}}
\def\CPU/{\textsc{cpu}}
\def\SUPERCOP/{\textsc{supercop}}
\def\Tarsnap/{Tarsnap}
\def\AESGCM/{AES\nobreakdash-GCM}
\def\AESGCMSIV/{AES\nobreakdash-GCM\nobreakdash-SIV}
\def\naclsecretbox/{crypto\_secretbox\_xsalsa20poly1305}
\def\naclonetimeauth/{crypto\_onetimeauth\_poly1305}
\def\libsodium/{libsodium}
\def\sodiumaead/{crypto\_aead}

\makeatletter
\def\newlatin#1#2{\def#1{\protect\@latin{#2}}}
\def\@latin#1{\@ifnextchar.{\@latinfinal{#1}}{\@latinmedial{#1}}}
\def\@latinfinal#1{\emph{#1}\@}
\def\@latinmedial#1{\emph{#1.}}
\makeatother
\newlatin\eg{e.g}
\newlatin\etc{etc}
\newlatin\etseq{et seq}
\newlatin\ie{i.e}
\newlatin\vs{vs}

\def\INDCPA{%
  \ifmmode\def\next{\operatorname{IND-CPA}}%
    \else\def\next/{\textsc{ind-cpa}}%
  \fi\expandafter\next}

\def\PRF{%
  \ifmmode\def\next{\operatorname{PRF}}%
    \else\def\next/{\textsc{prf}}%
  \fi\next}

\def\muPRF{%
  \ifmmode\def\next{\operatorname{mu-PRF}}%
    \else\def\next/{mu-\textsc{prf}}%
  \fi\next}

\def\PRG{%
  \ifmmode\def\next{\operatorname{PRG}}%
    \else\def\next/{\textsc{prg}}%
  \fi\next}

\def\SIV{%
  \ifmmode\def\next{\operatorname{SIV}}%
    \else\def\next/{\textsc{siv}}%
  \fi\next}

\def\DAE{%
  \ifmmode\def\next{\operatorname{DAE}}%
    \else\def\next/{\textsc{dae}}%
  \fi\next}

\def\AEAD{%
  \ifmmode\def\next{\operatorname{AEAD}}%
    \else\def\next/{\textsc{aead}}%
  \fi\next}

\def\muDAE{%
  \ifmmode\def\next{\operatorname{mu-DAE}}%
    \else\def\next/{mu-\textsc{dae}}%
  \fi\next}

\DeclareMathOperator{\Adv}{Adv}
\DeclareMathOperator{\DaenceEncrypt}{\textsc{Daence-Encrypt}}
\DeclareMathOperator{\DaenceDecrypt}{\textsc{Daence-Decrypt}}

\newcommand{\Z}{\mathbb Z}

\newcommand{\concat}{\mathbin\|}
\newcommand{\given}{\mathrel|}

\newcommand{\maxlength}{\ell}
\newcommand{\collisionbound}{\varepsilon}

\begin{document}

\maketitle

\begin{abstract}
  We present \DAENCE/, a deterministic authenticated cipher based on a
   256-bit-to-512-bit pseudorandom function family and a universal
   hash family with low collision probability.
  We recommend instantiation using \Salsa20/ or \ChaCha/, and
   \Poly1305/.

  \textbf{\textcolor{red}{\textsc{Warning}: The definition and
       analysis are works in progress.}}
\end{abstract}

\section{Introduction}

The nonce-based authenticated cipher
 crypto\_secretbox\_xsalsa20poly1305 in
 \NaCl/~\cite{bernstein2009naclcrypto}, and the variant
 \ChaCha//\Poly1305/ defined by the \IETF/~\cite{rfc7539} for
 \TLS/~\cite{rfc7905}, are widely available in fast software
 implementations resistant to timing side channels.
The nonce-based authenticated cipher \AESGCM/~\cite{nist-sp800-38d} is
 popular, though only with hardware support is it fast and resistant
 to timing side channels.

These three nonce-based ciphers fail catastrophically in the face of
 nonce reuse.
They are best suited to protocols that are designed to support
 sequential message numbers, such as the record number in \TLS/.
Some applications are unable to keep the state needed to maintain a
 sequential message number, and although they could use an extended
 nonce like \XSalsa20/ chosen randomly, some environments may not
 have a reliable entropy source.
The \emph{nonce-misuse-resistant} authenticated cipher
 \AESGCMSIV/~\cite{rfc8452} was developed to address these use cases,
 but it carries with it the performance and side channel costs of
 \AESGCM/---and amplifies the performance cost by deriving fresh keys
 for each distinct nonce, yet has very narrow security margins.

We propose a deterministic authenticated cipher \DAENCE/ built out of
 the \Salsa20/ or \ChaCha/ pseudorandom function family and the
 \Poly1305/ universal hash family.
The design is based on the \SIV/ construction of Rogaway and
 Shrimpton~\cite{rogaway-shrimpton2006keywrap}, with a
 variable-input-\PRF/ made by composing a universal hash family with a
 fixed-input \PRF/~%
  \cite[\S1.5]{bellare-canetti-krawczyk1996cascade}%
  \cite[\S9, Theorem~9.2]{bernstein1999hash127}.
\DAENCE/ is easily implemented in terms of the primitives available in
 \NaCl/ and \libsodium/.

\section{Security contract}

\DAENCE/ is a deterministic authenticated cipher.
This means it consists of two functions:
%
\begin{description}
  \item[\normalfont $c = \DaenceEncrypt(k, a, m)$] takes a 64-byte key
     $k$, a string $a$ of fewer than $2^{32}$ bytes of associated
     data, and a message $m$ of fewer than $2^{32}$ bytes.

    $\DaenceEncrypt$ returns an authenticated ciphertext $c$ which is
     24 bytes longer than $m$.

  \item[\normalfont $m' = \DaenceDecrypt(k, a', c')$] takes a 64-byte
     key $k$, a string $a'$ of fewer than $2^{32}$ bytes of associated
     data, and an alleged authenticated ciphertext $c'$ of fewer than
     $24 + 2^{32}$ bytes.

    \begin{itemize}
      \item If $c' = \DaenceEncrypt(k, a', m)$, $\DaenceDecrypt$
         returns $m$.
      \item Otherwise, $\DaenceDecrypt$ reports a forgery with high
         probability.
        In the sequel we denote this by the symbol `$\bot$'; in
         practice, a \texttt{crypto\_dae\_salsa20daence\_open}
         function in the style of \NaCl/ may return an error code or
         throw an exception.
    \end{itemize}
\end{description}

\paragraph*{Responsibilities of the user.}

\begin{enumerate}
  \item You must choose a secret key $k$ uniformly at random and
     independently of everything else in your application.
    (You may safely derive the 64-byte key $k$ from a 32-byte key $k'$
     by a key derivation function---\eg, $k = \Salsa20/_{k'}(0)$, or
     $k = \operatorname{HKDF-SHA256}_{k'}(\mathit{salt}, \text{`foo'})$.)

  \item If $\DaenceDecrypt$ reports a forgery, you must decline to act
     on the alleged message content except by immediately dropping it
     on the floor.

  \item You must process no more than a total of $2^{70}$ bytes of
     data, including associated data, with a single key.
\end{enumerate}

\paragraph*{Security guarantee.}

Under any key $k$ independently:

\begin{enumerate}
  \item If you repeat an associated data string, then an adversary has
     no hope of distinguishing the ciphertexts of \emph{distinct}
     messages from uniform random byte strings of the same length, but
     can tell when messages are repeated.

  \item If you do not repeat an associated data string, then an
     adversary has no hope of distinguishing the ciphertexts of your
     messages from uniform random byte strings of the same length.

  \item The adversary's probability of succeeding at forgery---even
     after flooding your system with up to $2^{70}$ bytes of forgery
     attempts---is less than $2^{-32}$.
\end{enumerate}

\noindent
\textcolor{red}{\textbf{XXX Triple-check these bounds!}}

\section{Definition}

\paragraph*{$\Poly1305/^2$.}
For 16-byte $k_1$, 16-byte $k_2$, and a byte string $m$, define
\[
  \Poly1305/^2_{k_1,k_2}(m)
  := \Poly1305/_{k_1}(m) \concat \Poly1305/_{k_2}(m),
\]
 and for byte strings $a$ and $m$, define
\[
  \Poly1305/^2_{k_1,k_2}(a, m)
  := \Poly1305/^2_{k_1,k_2}(h_a \concat h_m),
\]
 where
 $h_a = \Poly1305/^2_{k_1,k_2}(a)$
 and
 $h_m = \Poly1305/^2_{k_1,k_2}(m)$.

\paragraph*{\HXSalsa20/.}
For 32-byte key $k_0$ and 16-byte inputs $i$ and $j$, define
\[
  \HXSalsa20/_{k_0}(i \concat j) := \HSalsa20/_{\HSalsa20/_{k_0}(i)}(j).
\]
Note that \HXSalsa20/ can be defined in terms of \XSalsa20/ by
 choosing the appropriate words of the output and subtracting $j$,
 just as \HSalsa20/ can be defined in terms of
 \Salsa20/, and has comparable security~\cite{bernstein2011xsalsa}.

\paragraph*{Encryption.}
Given
 a 64-byte key $k$,
 associated data $a$ of fewer than $2^{32}$ bytes, and
 a message $m$ of fewer than $2^{32}$ bytes,
 compute:
%
\begin{enumerate}
  \item $k_0 \concat k_1 \concat k_2 := k$
    \hfill (32-byte $k_0$, 16-byte $k_1$, 16-byte $k_2$)
  \item $t \concat \_ := \HXSalsa20/_{k_0}(\Poly1305/^2_{k_1,k_2}(a, m))$
    \hfill (24-byte $t$)
  \item $c := m \oplus \bigl(\XSalsa20/_{k_0}(t \mathbin\| 0) \concat
      \XSalsa20/_{k_0}(t \mathbin\| 1) \concat \dotsb\bigr)$
\end{enumerate}
%
The authenticated ciphertext is $t \concat c$.

\paragraph*{Decryption.}
Given
 a 64-byte key $k$,
 associated data $a$ of fewer than $2^{32}$ bytes, and
 an alleged authenticated ciphertext $t' \concat c'$ of between $24$
 and $24 + 2^{32}$ bytes, compute:
%
\begin{enumerate}
  \item $k_0 \concat k_1 \concat k_2 := k$
    \hfill (32-byte $k_0$, 16-byte $k_1$, 16-byte $k_2$)
  \item $m' := c' \oplus \bigl(\XSalsa20/_{k_0}(t \mathbin\| 0) \concat
      \XSalsa20/_{k_0}(t \mathbin\| 1) \concat \dotsb\bigr)$
  \item $t' \concat \_ := \HXSalsa20/_{k_0}(\Poly1305/^2_{k_1,k_2}(a, m'))$
    \hfill (24-byte $t'$)
\end{enumerate}
%
If $t' \stackrel?= t$, return $m'$; otherwise erase $m'$ and report a
 forgery.

\paragraph*{\ChaCha/ alternative.}
Rather than hash the associated data separately, implementations of
 the \ChaCha//\Poly1305/ authenticated cipher used in \TLS/ and
 implemented in \libsodium/ \sodiumaead/ support passing associated
 data into \Poly1305/ natively with an 8-byte little-endian length
 prefix:
%
\begin{itemize}
  \item $k_0 \concat k_1 \concat k_2 := k$
    \hfill (32-byte $k_0$, 16-byte $k_1$, 16-byte $k_2$)
  \item $t \concat \_ :=
      \HXChaCha/_{k_0}(
        \Poly1305/^2_{k_1,k_2}(\lvert a\rvert \concat a \concat m))$
    \hfill (24-byte $t$)
  \item $c := m \oplus \bigl(\XChaCha20/_{k_0}(t \mathbin\| 0) \concat
      \XChaCha20/_{k_0}(t \mathbin\| 1) \concat \dotsb\bigr)$
\end{itemize}
%
The corresponding decryption operation is derived similarly.

\section{Analysis}

\begin{theorem}[\Salsa20/-\DAENCE/]\label{salsa20-daence}
  Let $A$ be a random decision algorithm with encryption and
   decryption oracles for a set of deterministic authenticated
   ciphers.
  Suppose $A$ submits $E(u)$ encryption queries and $D(u)$ decryption
   queries to the $u^{\mathit{th}}$ user of up to $\ell_a(u)$ bytes of
   associated data and $\ell_m(u)$-byte messages.
  Then there is an algorithm $A'$ making
   $\sum_u \bigl(1 + \lceil\ell_m(u)/64\rceil\bigr)
     \bigl(E(u) + D(u)\bigr)$
   oracle queries and having the cost of $A$ plus the cost of
   evaluating $\Poly1305/^2$ and $\oplus$ on
   $\sum_u E(u) + D(u)$
   different $(\ell_a(u), \ell_m(u))$-byte inputs,
   such that
%
  \begin{multline*}
    \Adv^{\muDAE}_{\DAENCE/}(A)
     \leq \Adv^{\muPRF}_{\XSalsa20/}(A') \\
            + \sum_u
                \frac{\bigl(E(u) + D(u)\bigr)^2 + D(u) + \binom{E(u)}{2}}
                     {2^{192}} \\
                + \collisionbound(\ell_a(u), \ell_m(u))
                  \cdot
                  {\textstyle\bigl(D(u) E(u) + \binom{E(u)}{2}\bigr)},
  \end{multline*}
%
   where
  \[
    \collisionbound(\ell_a, \ell_m)
    := \frac{\lceil\ell_a/16\rceil^2 + \lceil\ell_m/16\rceil^2 + 16}
            {2^{206}}.
  \]
\end{theorem}

\begin{theorem}[\ChaCha/-\DAENCE/]\label{chacha-daence}
  Let $A$ be a random decision algorithm with encryption and
   decryption oracles for a set of deterministic authenticated
   ciphers.
  Suppose $A$ submits $E(u)$ encryption queries and $D(u)$ decryption
   queries to the $u^{\mathit{th}}$ user of up to $\ell_a(u)$ bytes of
   associated data and $\ell_m(u)$-byte messages.
  Then there is an algorithm $A'$ making
   $\sum_u \bigl(1 + \lceil\ell_m(u)/64\rceil\bigr)
     \bigl(E(u) + D(u)\bigr)$
   oracle queries and having the cost of $A$ plus the cost of
   evaluating $\Poly1305/^2$ and $\oplus$ on
   $\sum_u E(u) + D(u)$
   different $(\ell_a(u), \ell_m(u))$-byte inputs,
   such that
%
  \begin{multline*}
    \Adv^{\muDAE}_{\DAENCE/}(A)
     \leq \Adv^{\muPRF}_{\XChaCha/}(A') \\
            + \sum_u
                \frac{\bigl(E(u) + D(u)\bigr)^2 + D(u) + \binom{E(u)}{2}}
                     {2^{192}} \\
                + \frac{\lceil(8 + \ell_a(u) + \ell_m(u))/16\rceil^2}{2^{206}}
                  \cdot
                  {\textstyle\bigl(D(u) E(u) + \binom{E(u)}{2}\bigr)}.
  \end{multline*}
\end{theorem}

\paragraph*{Outline of proof.}

\begin{enumerate}
  \item Set a bound on the collision probability of $\Poly1305/^2$.
  \item Set a bound on \DAE/ advantage against an idealized version of
     \DAENCE/.
  \item Extend the bound to the multi-user setting.
  \item Instantiate the idealization with the actual \PRF/.
\end{enumerate}

\subsection{Collisions under double-hashing with associated data}

\begin{lemma}[Double-hashing]\label{double-hash}
  Let $k_1$ and $k_2$ be independent \Poly1305/ keys.
  For any distinct strings $m \ne m'$ of at most $\ell$ bytes,
  \[
    \Pr[\Poly1305/^2_{k_1,k_2}(m) = \Poly1305/^2_{k_1,k_2}(m')]
    \leq \collisionbound(\ell)
    := \frac{\lceil\ell/16\rceil^2}{2^{206}}.
  \]
\end{lemma}

\begin{proof}
  By~\cite[Theorem~3.3]{bernstein2005poly1305},
  \[
    \Pr[\Poly1305/_{k_1}(m) = \Poly1305/_{k_1}(m')]
    \leq \frac{8\lceil\ell/16\rceil}{2^{106}},
  \]
   and likewise for $k_2$.
  Since $k_1$ and $k_2$ are independent,
  \begin{align*}
    \Pr&[\Poly1305/^2_{k_1,k_2}(m) = \Poly1305/^2_{k_1,k_2}(m')] \\
    &= \Pr[\Poly1305/_{k_1}(m) = \Poly1305/_{k_1}(m'), \\
    &\qquad\quad\Poly1305/_{k_2}(m) = \Poly1305/_{k_2}(m')] \\
    &= \Pr[\Poly1305/_{k_1}(m) = \Poly1305/_{k_1}(m')] \\
    &\quad
       \cdot
       \Pr[\Poly1305/_{k_2}(m) = \Poly1305/_{k_2}(m')] \\
    &\leq \biggl(\frac{8\lceil\ell/16\rceil}{2^{106}}\biggr)^2
     = \frac{64\lceil\ell/16\rceil^2}{2^{212}}
     = \frac{\lceil\ell/16\rceil^2}{2^{206}}.
    \qedhere
  \end{align*}
\end{proof}

\begin{lemma}[Hashing associated data]\label{hash-ad}
  Let $k_1$ and $k_2$ be independent \Poly1305/ keys.
  For strings $a \ne a'$ of up to $\ell_a$ bytes, and strings
   $m \ne m'$ of up to $\ell_m$ bytes,
%
  \begin{multline*}
    \Pr[\Poly1305/^2_{k_1,k_2}(a, m) = \Poly1305/^2_{k_1,k_2}(a', m')] \\
    \leq \collisionbound(\ell_a, \ell_m)
    := \frac{\lceil\ell_a/16\rceil^2 + \lceil\ell_m/16\rceil^2 + 16}
            {2^{206}}.
  \end{multline*}
\end{lemma}

\begin{proof}
  Let
   $h_a = \Poly1305/^2_{k_1,k_2}(a)$
   and
   $h_m = \Poly1305/^2_{k_1,k_2}(m)$,
   and likewise $h_{a'}$ and $h_{m'}$.
  By Lemma~\ref{double-hash},
   $\Pr[h_a = h_{a'}] \leq \collisionbound(\ell_a)$
   and
   $\Pr[h_m = h_{m'}] \leq \collisionbound(\ell_m)$.
  Thus,
   $\Pr[(h_a, h_m) = (h_{a'}, h_{m'})]
     \leq \Pr[h_a = h_{a'}] + \Pr[h_m = h_{m'}]
     \leq \collisionbound(\ell_a) + \collisionbound(\ell_m)$.
  Conditional on $(h_a, h_m) \ne (h_{a'}, h_{m'})$, the 64-byte
   strings $h_a \concat h_m$ and $h_{a'} \concat h_{m'}$ collide under
   $\Poly1305/^2$ with probability at most
   $\collisionbound(64)$.
  Hence
%
  \begin{align*}
    \Pr&[\Poly1305/^2_{k_1,k_2}(a, m) = \Poly1305/^2_{k_1,k_2}(a', m')] \\
    &= \Pr[\Poly1305/^2_{k_1,k_2}(h_a \concat h_m)
             = \Poly1305/^2_{k_1,k_2}(h_{a'} \concat h_{m'})] \\
    &\leq \Pr[h_a = h_{a'}] + \Pr[h_m = h_{m'}] \\
    &\qquad + \Pr[\Poly1305/^2_{k_1,k_2}(h_a \concat h_m)
                    = \Poly1305/^2_{k_1,k_2}(h_{a'} \concat h_{m'}) \\
    &\qquad\qquad\quad \given (h_a, h_m) \ne (h_{a'}, h_{m'})] \\
    &\leq \varepsilon(\ell_a) + \varepsilon(\ell_m)
          + \varepsilon(64) \\
    &= \frac{\lceil\ell_a/16\rceil + \lceil\ell_m/16\rceil + 16}
            {2^{206}}.
    \qedhere
  \end{align*}
\end{proof}

\subsection{Idealizing the cipher}

For a function $\phi$ yielding bit strings, denote by $\phi_{192}$ the
 first 192 bits of $\phi$; denote by $\hat\phi$ the transformation so
 that if $\phi = \XSalsa20/$ then $\hat\phi = \HXSalsa20/$; and denote
 by $\phi_*(t)$ the concatenation
 $\phi(t \concat 0) \concat \phi(t \concat 1) \concat \dotsb$,
 with input counter encoded in little-endian, and with output
 understood to be as long as is needed.
Let $f,g\colon \{0,1\}^{256} \to \{0,1\}^{512}$ be uniform random.
Note that $\hat f$, $\hat f_{192}$, $f_*$, and $g_*$ are uniformly
 distributed.

Define \term{\DEUCE/} to be as \DAENCE/, but with $f$ substituted for
 $\XSalsa20/_{k_0}$:
%
\begin{enumerate}
  \item $h := \Poly1305/^2_{k_1,k_2}(m)$
    \hfill (32-byte $h$)
  \item $t := \hat f_{192}(h)$
    \hfill (24-byte $t$)
  \item $c := m \oplus f_*(t)$
\end{enumerate}

Define \term{\DICE/} to be as \DEUCE/, but with $g$ substituted for
 $f$ in the pad:
%
\begin{enumerate}
  \item $h := \Poly1305/^2_{k_1,k_2}(m)$
    \hfill (32-byte $h$)
  \item $t := \hat f_{192}(h)$
    \hfill (24-byte $t$)
  \item $c := m \oplus g_*(t)$
\end{enumerate}

Finally, define \term{\DUNCE/} to be as \DICE/, but with the
 decryption oracle modified to return $\bot$ for every input.

\begin{lemma}[Single-user idealized security]\label{su-ideal}
  Let $A$ be a random decision algorithm with encryption and
   decryption oracles for a deterministic authenticated cipher.
  Suppose $A$ makes $E$ encryption queries and $D$ decryption queries
   of up to $\ell_a$ bytes of associated data and $\ell_m$-byte
   messages.
  Then
  \[
    \Adv^{\DAE}_{\DEUCE/}(A)
    \leq \frac{(E + D)^2 + D + \binom{E}{2}}{2^{192}}
         + \collisionbound(\ell_a, \ell_m)
           \cdot
           {\textstyle\bigl(D E + \binom{E}{2}\bigr)}.
  \]
\end{lemma}

\paragraph*{Distinguishing \DEUCE/ from \DICE/: independent tags and pads.}
\leavevmode\hfill\break
\DICE/ is simply \DEUCE/ with two independent functions for deriving a
 tag $t$ from a hash $h$ for deriving a pad from a tag.
Only in the event $C_{th}$ of a collision between one of the values of
 $h$ and one of the values of $t \concat j$ do \DICE/ and \DEUCE/ have
 different distributions, since if the $h$ do not overlap with the
 $t \concat j$, then the $f(t \concat j)$ and $g(t \concat j)$ are
 both uniform random strings independent of the $\hat f_{192}(h)$.
And since $f(t \concat j)$ does not figure into \DICE/, a collision
 between a value of $h$ and a value of $t \concat j$ value cannot
 affect the outcome, so
 $\Pr[A(\DICE/) \given \lnot C_{th}] = \Pr[A(\DICE/)]$.
Thus,
%
\begin{align*}
  \Pr[A(\DEUCE/)]
  &= \Pr[A(\DEUCE/) \given C_{th}] \Pr[C_{th}] \\
  &\qquad
     + \Pr[A(\DEUCE/) \given \lnot C_{th}] \Pr[\lnot C_{th}] \\
  &\leq \Pr[C_{th}] + \Pr[A(\DEUCE/) \given \lnot C_{th}] \\
  &= \Pr[C_{th}] + \Pr[A(\DICE/) \given \lnot C_{th}] \\
  &= \Pr[C_{th}] + \Pr[A(\DICE/)].
\end{align*}

How often do collisions occur?
It suffices to consider the event $C_{th_{192}}$ of a collision
 between a $t$ and just the upper 192 bits of an $h$; call it
 $h_{192}$.
There are at most $E + D$ distinct values of $h$ and thus of
 $h_{192}$.
The values of $t$ are independent uniform 192-bit strings, and there
 are up to $E + D$ of them, so
\[
  \Pr[C_{th}]
  \leq \Pr[C_{th_{192}}]
  \leq \sum_{i=1}^{E + D} \frac{E + D}{2^{192}}
  = \frac{(E + D)^2}{2^{192}}.
\]

Finally, since $A$ was arbitrary and could be replaced by $\lnot A$,
 we have
\[
  \lvert\Pr[A(\DEUCE/)] - \Pr[A(\DICE/)]\rvert
  \leq \Pr[C_{th}]
  \leq \frac{(E + D)^2}{2^{192}}.
\]

\paragraph*{Distinguishing \DICE/ from \DUNCE/: bounding forgery
  probability.}
\leavevmode\hfill\break
The decryption oracle of \DICE/ returns anything other than
 $\bot$ only in the event $F$ that $A$ forges a ciphertext not
 returned by the encryption oracle.
Conditional on $\lnot F$, \DICE/ and \DUNCE/ otherwise have the same
 distribution---the encryption oracle is the same and the decryption
 oracle always returns $\bot$ in both cases---so
%
\begin{align*}
  \Pr[A(\DICE/)]
  &= \Pr[A(\DICE/) \given F] \Pr[F]
     + \Pr[A(\DICE/) \given \lnot F] \Pr[\lnot F] \\
  &\leq \Pr[F] + \Pr[A(\DICE/) \given \lnot F] \\
  &= \Pr[F] + \Pr[A(\DUNCE/)],
\end{align*}
%
 and thus
\[
  \lvert\Pr[A(\DICE/)] - \Pr[A(\DUNCE/)]\rvert
  \leq \Pr[F].
\]

Assume $A$ halts after the first forgery attempt---an adversary that
 makes $D>1$ forgery attempts can be broken into one that halts after
 the first forgery attempt, and another one that simulates forgery
 failure for the first attempt before making $D-1$ more attempts.
If the first succeeded with probability at most $p$, then by induction
 the second succeeds with probability at most $(D - 1) p$, so that the
 original succeeds with probability at most $p + (D - 1) p = D p$.

Suppose $A$ submits distinct encryption queries
 $(a_1, m_1), \dotsc, (a_E, m_E)$
 giving answers
 $t_1 \concat c_1, \dotsc, t_E \concat c_E$
 via intermediate hashes
 $h_i = \Poly1305/^2_{k_1,k_2}(a_i, m_i)$,
 so that $t_i = f(h_i)$ and $c_i = m_i \oplus g_*(t_i)$.
Suppose $A$ attempts a forgery $(a', t', c')$ with
 $t' \concat c' \ne t_i \concat c_i$ for all $i$.
Let
 $m' = c' \oplus g_*(t')$
 and
 $h' = \Poly1305/^2_{k_1,k_2}(a', m')$.
The forgery succeeds if $t' = f(h')$.
Note that $(a', m') \ne (a_i, m_i)$, for if
 $(a', m') = (a_i, m_i)$,
 then we would have
 $t' \concat c' = t_i \concat c_i$, since---for fixed $f$, $g$, $k_1$,
 and $k_2$---$t' \concat c'$ is a deterministic function of
 $(a', m')$.

The string $f(h')$ is a uniform random 192-bit string independent of
 the $t_i$ and $c_i$, except in the event $C_{h'}$ that $h'$ coincides
 with one of the $h_i$:
%
\begin{align*}
  \Pr[C_{h'}]
  &= \Pr[\exists i\colon h' = h_i]
   \leq \sum_i \Pr[h' = h_i] \\
  &= \sum_i
       \Pr[\Poly1305/^2_{k_1,k_2}(a', m')
             = \Poly1305/^2_{k_1,k_2}(a_i, m_i)] \\
  &\leq \sum_i \collisionbound(\ell_a, \ell_m)
   = E \cdot \collisionbound(\ell_a, \ell_m).
\end{align*}
%
Hence
%
\begin{align*}
  \lvert\Pr[A(\DICE/)] &- \Pr[A(\DUNCE/)]\rvert
   \leq \Pr[F] \\
  &\leq D \cdot \Pr\bigl[t' = f(h')
            \given t_i = f(h_i), c_i = m_i \oplus g_*(t_i)\bigr] \\
  &\leq D \cdot \bigl(\Pr[t' = f(h') \given \lnot C_{h'}]
                      + \Pr[C_{h'}]\bigr) \\
  &\leq \frac{D}{2^{192}}
        + D E \cdot \collisionbound(\ell_a, \ell_m).
\end{align*}

\paragraph*{Distinguishing \DUNCE/ from uniform random.}
Let $U_1$ be a pathological `\DAE/' whose encryption oracle returns an
 independent uniform random tag and ciphertext for each distinct
 input, and whose decryption oracle returns $\bot$ for every input.
Suppose $A$ submits distinct encryption queries
 $(a_1, m_1), \dotsc, (a_E, m_E)$
 giving answers
 $t_1 \concat c_1, \dotsc, t_E \concat c_E$.
If the oracle is \DUNCE/, then all the strings $t_i = f(h_i)$ and
 $c_i = m_i \oplus g_*(t_i)$ are independent uniform random---and thus
 the oracle is indistinguishable from $U_1$---except in the event
 $C_h$ of a collision $h_i = h_j$ for some $i \ne j$, or in the event
 $C_t$ of a collision $t_i = t_j$ for some $i \ne j$:
%
\begin{align*}
  \Pr[C_h]
    &= \Pr[\exists i<j\colon h_i = h_j]
     \leq \sum_{i<j} \Pr[h_i = h_j] \\
    &= \sum_{i<j}
         \Pr[\Poly1305/^2_{k_1,k_2}(a_i, m_i)
               = \Poly1305/^2_{k_1,k_2}(a_j, m_j)] \\
    &\leq \sum_{i<j} \collisionbound(\ell_a, \ell_m)
     = \binom{E}{2} \collisionbound(\ell_a, \ell_m).
\end{align*}
%
If the $h_i$ are all distinct, there is a collision among the $t_i$
 only with probability
%
\begin{align*}
  \Pr[C_t \given \lnot C_h]
    &= \Pr[\exists i<j\colon t_i = t_j \given \lnot C_h]
     \leq \sum_{i<j} \Pr[t_i = t_j \given \lnot C_h] \\
    &= \sum_{i<j} \Pr[f(h_i) = f(h_j) \given h_i \ne h_j]
     \leq \sum_{i<j} \frac{1}{2^{192}}
     = \binom{E}{2} \frac{1}{2^{192}}.
\end{align*}
%
Thus,
%
\begin{align*}
  \Pr[A(\DUNCE/)]
  &\leq \Pr\bigl[A(\DUNCE/) \given
            \lnot (C_h \mathrel{\text{or}} C_t)\bigr]
        + \Pr[C_h \mathrel{\text{or}} C_t] \\
  &= \Pr[A(U_1)] + \Pr[C_h \mathrel{\text{or}} C_t] \\
  &\leq \Pr[A(U_1)] + \Pr[C_h] + \Pr[C_t \given \lnot C_h] \\
  &\leq \Pr[A(U_1)] + \binom{E}{2} \collisionbound(\ell_a, \ell_m)
        + \binom{E}{2} \frac{1}{2^{192}},
\end{align*}
%
 so that
\[
  \lvert\Pr[A(\DUNCE/)] - \Pr[A(U_1)]\rvert
  \leq \binom{E}{2}
       \biggl(\collisionbound(\ell_a, \ell_m) + \frac{1}{2^{192}}\biggr).
\]

\paragraph*{Summing it up.}

\begin{align*}
  \lvert\Pr&[A(\DEUCE/)] - \Pr[A(U_1)]\rvert \\
  &\leq \lvert\Pr[A(\DEUCE/)] - \Pr[A(\DICE/)]\rvert
          + \lvert\Pr[A(\DICE/)] - \Pr[A(\DUNCE/)]\rvert \\
  &\qquad + \lvert\Pr[A(\DUNCE/)] - \Pr[A(U_1)]\rvert \\
  &\leq \frac{(E + D)^2}{2^{192}}
          + \frac{D}{2^{192}} + D E \cdot \collisionbound(\ell_a, \ell_m)
          + \binom{E}{2}
            \biggl(\collisionbound(\ell_a, \ell_m)
                     + \frac{1}{2^{192}}\biggr) \\
  &= \frac{(E + D)^2 + D + \binom{E}{2}}{2^{192}}
     + \collisionbound(\ell_a, \ell_m)
       \cdot
       {\textstyle\bigl(D E + \binom{E}{2}\bigr)}.
  \tag*\qed
\end{align*}

\subsection{Multi-user security}

\begin{lemma}[Multi-user idealized security]\label{mu-ideal}
  Let $A$ be a random decision algorithm with encryption and
   decryption oracles for a \emph{set} of deterministic authenticated
   ciphers.
  Suppose $A$ makes $E(u)$ encryption queries and $D(u)$ decryption
   queries to the $u^{\mathit{th}}$ user of up to $\ell_a(u)$ bytes of
   associated data and $\ell_m(u)$-byte messages.
  Then
%
  \begin{multline*}
    \Adv^{\muDAE}_{\DEUCE/}(A)
    \leq \sum_u \frac{\bigl(E(u) + D(u)\bigr)^2 + D(u) + \binom{E(u)}{2}}
                     {2^{192}} \\
           + \collisionbound(\ell_a(u), \ell_m(u))
             \cdot
             {\textstyle\bigl(D(u) E(u) + \binom{E(u)}{2}\bigr)}.
  \end{multline*}
\end{lemma}

\begin{proof}
  In the foregoing analysis of the idealized cipher in the single-user
   setting (Lemma~\ref{su-ideal}), the probabilities of the critical
   events---$C_{th}$, $F$, $C_{h'}$, $C_h$, and $C_t$---can be
   straightforwardly seen to sum over the users independently.
  For example, the event $C_{th}$ of a collision in \emph{any one} of
   the users each with their own independent function $f$ and key
   $(k_1, k_2)$ is the sum over all users of $C_{th}$ for each user
   separately.
  Consequently, the multi-user \DAE/ advantage against \DEUCE/---that
   is, the statistical distance under $A$ from \DEUCE/ to a
   pathological `\DAE/' collection $U$---is at most the sum of the
   single-user \DAE/ advantages.
\end{proof}

\subsection{Instantiating the idealized cipher}

\begin{lemma}[Multi-user instantiation]\label{mu-instance}
  Let $A$ be a random decision algorithm with encryption and
   decryption oracles for a \emph{set} of deterministic authenticated
   ciphers.
  Suppose $A$ makes $E(u)$ encryption queries and $D(u)$ decryption
   queries to the $u^{\mathit{th}}$ user of up to $\ell_a(u)$ bytes of
   associated data and $\ell_m(u)$-byte messages.
  Then there is an algorithm $A'$ making
   $\sum_u \bigl(1 + \lceil\ell_m(u)/64\rceil\bigr)
     \bigl(E(u) + D(u)\bigr)$
   oracle queries and having the cost of $A$ plus the cost of
   evaluating $\Poly1305/^2$ and $\oplus$ on
   $\sum_u E(u) + D(u)$
   different $(\ell_a(u), \ell_m(u))$-byte inputs,
   such that
  \[
    \lvert\Pr[A(\DAENCE/)] - \Pr[A(\DEUCE/)]\rvert
    = \Adv^{\muPRF}_{\XSalsa20/}(A').
  \]
\end{lemma}

\begin{proof}
  \DEUCE/ is simply \DAENCE/ with a uniform random function $f$
   substituted for $\XSalsa20/_{k_0}$, so if $A$ can distinguish a
   collection of \DAENCE/ users from a collection of \DEUCE/ users then
   it can be used in an algorithm $A'$ to distinguish a collection of
   $\XSalsa20/_{k_0}$ users from a collection of $f$ users (recall
   $f\colon \{0,1\}^{256} \to \{0,1\}^{512}$ is a
   uniform random function).

  If $\mathcal O(u,x)$ is an oracle for a collection of function
   instances indexed by $u$, define $A'(\mathcal O)$ to run $A$ with
   oracles for the following \DAE/ under independent uniform random keys
   $k_1 \concat k_2$ for the $u^{\mathit{th}}$ user, decryption being
   defined the obvious way:
  %
  \begin{enumerate}
    \item $h := \Poly1305/^2_{k_1,k_2}(a, m)$
      \hfill (32-byte $h$)
    \item $t := \hat{\mathcal O}_{192}(u, h)$
      \hfill (24-byte $t$)
    \item $c := m \oplus \mathcal O_*(u, t)$
  \end{enumerate}
  %
  Then $A'(\XSalsa20/_{k_0}) = A(\DAENCE/)$ and $A'(f) = A(\DEUCE/)$
   (with `$k_0$' and `$f$' understood to mean a collection of
   independent keys/functions), so
  %
  \begin{align*}
    \lvert\Pr[A(\DAENCE/)] - \Pr[A(\DEUCE/)]\rvert
    &= \lvert\Pr[A'(\XSalsa20/_{k_0})] - \Pr[A'(f)]\rvert \\
    &= \Adv^{\muPRF}_{\XSalsa20/}(A').
    \qedhere
  \end{align*}
\end{proof}

\subsection{Tying the room together}

\begin{proof}[Proof of Theorem~\ref{salsa20-daence}]
  By stringing all the inequlities together, we complete the proof:
%
  \begin{align*}
    \Adv^{\muDAE}_{\DAENCE/}(A)
    &= \lvert\Pr[A(\DAENCE/)] - \Pr[A(U)]\rvert \\
    &\leq \lvert\Pr[A(\DAENCE/)] - \Pr[A(\DEUCE/)]\rvert \\
    &\qquad + \lvert\Pr[A(\DEUCE/)] - \Pr[A(U)]\rvert \\
    &= \Adv^{\muPRF}_{\XSalsa20/}(A')
       + \lvert\Pr[A(\DEUCE/)] - \Pr[A(U)]\rvert \\
    &\leq \Adv^{\muPRF}_{\XSalsa20/}(A') \\
    &\qquad
       + \sum_u \frac{\bigl(E(u) + D(u)\bigr)^2 + D(u) + \binom{E(u)}{2}}
                     {2^{192}} \\
    &\qquad\qquad\qquad
           + \collisionbound(\ell_a(u), \ell_m(u))
             \cdot
             {\textstyle\bigl(D(u) E(u) + \binom{E(u)}{2}\bigr)}.
    \qedhere
  \end{align*}
\end{proof}

\begin{proof}[Proof of Theorem~\ref{chacha-daence}]
  The \ChaCha/ version of \DAENCE/ uses
  \[
    \Poly1305/^2_{k_1,k_2}(\lvert a\rvert \concat a \concat m)
    \qquad\text{instead of}\qquad
    \Poly1305/^2_{k_1,k_2}(a, m).
  \]
  By~Lemma~\ref{double-hash}, the collision probability is bounded by
   $\collisionbound(8 + \ell_a + \ell_m)$ rather than by
   $\collisionbound(\ell_a, \ell_m)$; the rest of the analysis carries
   over identically, with \XChaCha/ in the place of \XSalsa20/.
\end{proof}

\section{Shaving IAQs---Infrequently Asked Questions}

\begin{description}
  \item[Why not just use the \CAESAR/ competition winner?]
    In our estimation, the \CAESAR/
     competition\footnote{\CAESAR/: Competition for Authenticated
        Encryption: Security, Applicability, and Robustness.
       \url{https://competitions.cr.yp.to/caesar.html}}
     was too broad and dragged on for too long, and in the end failed
     to gain the traction it needed.
    While \NaCl/, \IETF/ \ChaCha//\Poly1305/, and \AESGCM/ are
     ubiquitous today, with a variety of high-quality implementations
     available in many programming languages, the benefits of the
     \CAESAR/ winners do not seem to justify the engineering effort to
     make the novel cryptographic primitives as ubiquitous.
    In contrast, \DAENCE/ requires negligible engineering effort on
     top of \NaCl/ or \libsodium/.

  \item[Why not just use \AESGCMSIV/?]
    \AESGCMSIV/ is optimized for applications that can
     \emph{guarantee} hardware support for the primitives---otherwise
     it may be subject to severe performance degradation and/or timing
     side channel attacks.
    This may be reasonable when the engineer can control everything
     about the hardware and software stack, and audit the software
     stack all the way down to the hardware to ensure safety, but it
     does not make for a good general-purpose tool.

    The \AESGCMSIV/ security guarantee requires unusually detailed
     safe usage limits~\cite[\S9]{rfc8452}, and users are advised to
     choose nonces at random---which is exactly the opposite of the
     advice for nonce-based ciphers like \AESGCM/ and \NaCl/
     \naclsecretbox/.
    This limits \AESGCMSIV/'s value as a drop-in replacement for
     nonce-based ciphers with a safety net for \Tarsnap/-style
     accidental nonce reuse
     bugs~\cite{cperciva2011tarsnap-nonce-reuse} and virtual machine
     rollbacks, and makes applications \emph{more} vulnerable to
     broken entropy sources than \DAENCE/ would.

  \item[Why not a nonce-misuse-resistant authenticated cipher?]
    If you have a nonce---say a message sequence number---then you can
     use it in the associated data.
    So out of \DAENCE/ you can build your own nonce-misuse-resistant
     authenticated cipher: just prefix a fixed-size nonce to the
     associated data!

    But there is a conceptual cost to \emph{requiring} a nonce
     parameter \emph{and} associated data---what are you supposed to
     put in the nonce and what are you supposed to put in the
     associated data?
    The terms `nonce' and `nonce-misuse-resistant authenticated
     cipher' are confusing to non-experts (not to mention the
     British).

    The security bounds could be better if we derived a fresh key for
     each distinct nonce like \AESGCMSIV/ does.
    But \AESGCMSIV/ has weaker security bounds to begin with.
    At the level of security that \DAENCE/ provides, there is little
     reason to pay the interface complexity cost.

  \item[Why bother with \Salsa20/?  Why not just \ChaCha/?]
    \hspace{\stretch{1}}\penalty-300
    The \NaCl/ \naclonetimeauth/ interface is widely available in many
     languages, particularly via TweetNaCl.
    It is easy to implement \Salsa20/-\DAENCE/ in terms of this
     interface, but not \ChaCha/-\DAENCE/.

    On the other hand, \ChaCha//\Poly1305/ is seeing wider use after
     \IETF/ standardization in \TLS/---and systems with
     \ChaCha//\Poly1305/ will generally have the parts needed to
     implement \ChaCha/-\DAENCE/ just as easily.

    There is a small security advantage to the hashing in
     \Salsa20/-\DAENCE/; there may be a small performance advantage to
     the hashing in \ChaCha/-\DAENCE/; but the primary advantage to
     defining both alternatives is to reduce the engineering costs to
     adopting either one in environments that already use \NaCl/ or
     already implement \ChaCha//\Poly1305/.

  \item[How fast is it?]
    The main cost over \naclsecretbox/ is evaluating \Poly1305/ twice
     rather than once, and completing it before starting \XSalsa20/,
     so \Salsa20/-\DAENCE/ should cost about 1--2x what
     \naclsecretbox/ costs.
    If the analysis survives some scrutiny, we will submit \DAENCE/ to
     \SUPERCOP/\footnote{\url{https://bench.cr.yp.to/}} for reliable,
     fair measurements across a variety of machines.

    But if you must see rough numbers first, on our Intel Core~i7,
     \SUPERCOP/ measures
     ${\approx}2.5\,\mathrm{cpb}$ for \naclsecretbox/,
     ${\approx}1.9\,\mathrm{cpb}$ for hardware-accelerated \AESGCM/,
     and
     ${\approx}3.6\,\mathrm{cpb}$ for \Salsa20/-\DAENCE/.
    There is room for improvement: this na\"ive code makes no attempt
     to compute the two \Poly1305/'s in parallel, which may be faster
     than computing them serially---especially for messages exceeding
     the \CPU/ cache.

  \item[Does \DAENCE/ support streaming?]
    No.
    If you want to stream large files, break them into bite-size
     pieces first, and include the piece number and an end-of-stream
     flag in the associated data.
    Make sure the pieces are no larger than the amount of memory you
     are willing to let an adversary waste with a forgery if they are
     carrying out a denial of service attack.
\end{description}

\noindent
We do not anticipate that \DAENCE/ will replace \ChaCha//\Poly1305/ in
 major protocols such as \TLS/ designed by world-class cryptographers,
 which can easily take advantage of a message number guaranteed not to
 repeat.
We do hope that \DAENCE/ will find its way into the repertoire of
 general-purpose application engineers who need to store messages safe
 from eavesdropping and forgery in diverse software
 environments---%
 \emph{without} auditing the software stack all the way down to
  machine instructions to ensure their use of \AESGCMSIV/ is safe from
  timing side channels,
 \emph{without} adopting unusual cryptographic primitives or an
  entirely new cryptography library, and
 \emph{without} teetering on the brink of catastrophe from nonce reuse
  in \naclsecretbox/ or \AESGCM/.

\bibliography{daence}

\newpage
\appendix

\section{Tweetable implementation}

\lstinputlisting[basicstyle=\small\ttfamily,tabsize=4]{tweetdaence.c}

\section{Reference implementation}

\lstinputlisting[basicstyle=\small\ttfamily,tabsize=4,formfeed=\newpage]
  {testvector.c}

\newpage
\section{Test vectors}

\lstinputlisting[basicstyle=\small\ttfamily]{testvector.out}

\end{document}
