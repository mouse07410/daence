Daence - Deterministic Authenticated Encryption with no noNCEnse
Taylor `Riastradh' Campbell <campbell+daence@mumble.net>

   WARNING: Daence is a work in progress.  The definition and API may
   change.  There may be bugs or mistakes in the security analysis.

Daence is a deterministic authenticated cipher built out of Poly1305
and either Salsa20 or ChaCha.  This repository contains a definition,
security analysis, reference implementation, and test vectors for
Daence.


If you and your friend share a secret 64-byte key for Daence:

- You can feed in a header and a payload of up to 2^32 bytes, and
  Daence-Encrypt returns an authenticated ciphertext concealing the
  payload, which you send to your friend in an envelope with the
  header on it in the clear.

    c = Daence-Encrypt(key, header, payload)

- Your friend can feed the header and authenticated ciphertext into
  Daence-Decrypt, which either returns the payload, if it was genuine,
  or reports a forgery, if it was not.  (Your friend must immediately
  drop forgeries on the floor and forget about them.)

    payload = Daence-Decrypt(key, header, c) or raise Forgery!

Unlike AES-GCM, ChaCha/Poly1305, or crypto_secretbox_xsalsa20poly1305,
you do not need to guarantee that every message has a unique number --
though if you have one you can put it in the header to improve
security.

Then, as long as you and your friend handle no more than 2^70 bytes
under a single key:

- An adversary has no hope of distinguishing authenticated ciphertexts
  from uniform random noise, except for noticing when you repeat the
  same (header, payload) pair under the same key.  (You can prevent
  adversaries from detecting repeated messages by putting a message
  sequence number or just randomization in the header or payload, for
  example.)

- An adversary has no hope of fooling your friend into accepting a
  payload and a header you did not send.  (Daence can also serve to
  authenticate messages without encryption if you simply specify an
  empty payload.)

Salsa20-Daence provides good performance and high security, and admits
a short implementation in terms of three primitives available in NaCl
and libsodium -- crypto_onetimeauth_poly1305, crypto_core_hsalsa20,
and crypto_stream_xsalsa20.  (The ChaCha-Daence variant is defined in
terms of parts that a ChaCha/Poly1305 implementation is likely to have
around.)

Daence won't beat speed records for ChaCha/Poly1305, NaCl
crypto_secretbox_xsalsa20poly1305, or (hardware-accelerated) AES-GCM
-- but who cares about speed when you accidentally repeated a nonce
and thereby leaked all your data to the adversary including the key to
forgery?


Makefile        machine-readable instructions for building everything
README          you are here
crypto_aead/    SUPERCOP AEAD API for you to copypasta
crypto_auth/    SUPERCOP PRF/authenticator API
daence.bib      bibliography
daence.tex      definition and analysis
t_daence.c      a test program to verify crypto_aead/salsa20daence/ref
t_tweetdaence.c a test program to verify tweetdaence.c
testvector.c    reference implementation and test vector generation
testvector.exp  expected values of test vectors
tweetdaence.c   tweetnacl-style implementation in 48 lines (plus header)
tweetdaence.h   header file with prototypes for tweetdaence.c
tweetnacl/      a copy of tweetnacl-20140427 <https://tweetnacl.cr.yp.to/>


* Building the specification and testing the implementation

You will need libsodium <https://libsodium.org/> and a TeX
distribution.  Run

   make

and let me know if anything goes wrong.  If it worked, you should have
a shiny new copy of the definition and analysis in daence.pdf, and
evidence that the reference implementation worked on your machine too.

Currently missing: reference implementation and test vectors for
ChaCha-Daence.


* Measuring performance with SUPERCOP <https://bench.cr.yp.to/>

   cd /path/to/supercop-YYYYMMDD
   ln -s /path/to/daence/crypto_aead/salsa20daence crypto_aead/.
   ln -s /path/to/daence/crypto_auth/salsa20daence crypto_auth/.

Now run SUPERCOP, as <https://bench.cr.yp.to/supercop.html> explains.
If you want to measure just Salsa20-Daence, you will first need:

   ./do-part crypto_verify 16
   ./do-part crypto_verify 32
   ./do-part crypto_core salsa20
   ./do-part crypto_core hsalsa20
   ./do-part crypto_stream salsa20
   ./do-part crypto_stream xsalsa20
   ./do-part crypto_onetimeauth poly1305

Then you can measure crypto_aead/salsa20daence and
crypto_auth/salsa20daence, in that order (the auth uses the aead as a
subroutine -- the auth is just the aead with empty payload):

   ./do-part crypto_aead salsa20daence
   ./do-part crypto_auth salsa20daence

Raw output will be in: ./bench/`hostname`/data

(Plotting data left as an exercise for the conspiratorially-minded
reader.)
